"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeJestBinCmd = void 0;
const os_1 = require("os");
const coc_nvim_1 = require("coc.nvim");
const path_1 = require("path");
const fs_1 = require("fs");
/**
 * Known binary names of `react-scripts` forks
 */
const createReactAppBinaryNames = [
    'react-scripts',
    'react-native-scripts',
    'react-scripts-ts',
    'react-app-rewired',
];
/**
 * File extension for npm binaries
 */
const nodeBinExtension = (0, os_1.platform)() === 'win32' ? '.cmd' : '';
/**
 * Resolves the location of an npm binary
 *
 * Returns the path if it exists, or `undefined` otherwise
 */
const getLocalPathForExecutable = (rootPath, executable) => {
    const absolutePath = (0, path_1.normalize)((0, path_1.join)(rootPath, 'node_modules', '.bin', executable + nodeBinExtension));
    return (0, fs_1.existsSync)(absolutePath) ? absolutePath : undefined;
};
/**
 * Tries to read the test command from the scripts section within `package.json`
 *
 * Returns the test command in case of success,
 * `undefined` if there was an exception while reading and parsing `package.json`
 * `null` if there is no test script
 */
const getTestCommand = (rootPath) => {
    var _a;
    try {
        const packagePath = (0, path_1.join)(rootPath, 'package.json');
        const packageJSON = JSON.parse((0, fs_1.readFileSync)(packagePath, 'utf8'));
        if ((_a = packageJSON === null || packageJSON === void 0 ? void 0 : packageJSON.scripts) === null || _a === void 0 ? void 0 : _a.test) {
            return packageJSON.scripts.test;
        }
        return null;
    }
    catch (_b) {
        return undefined;
    }
};
/**
 * Checks if the supplied test command could have been generated by create-react-app
 */
const isCreateReactAppTestCommand = (testCommand) => {
    return (!!testCommand &&
        createReactAppBinaryNames.some((binary) => testCommand.includes(`${binary} test`)));
};
/**
 * Checks if the project in `rootPath` was bootstrapped by `create-react-app`.
 */
const isBootstrappedWithCreateReactApp = (rootPath) => {
    const testCommand = getTestCommand(rootPath);
    if (testCommand === undefined) {
        // In case parsing `package.json` failed or was unconclusive,
        // fallback to checking for the presence of the binaries in `./node_modules/.bin`
        return createReactAppBinaryNames.some((binary) => getLocalPathForExecutable(rootPath, binary) !== undefined);
    }
    return isCreateReactAppTestCommand(testCommand);
};
/**
 * Handles getting the jest runner, handling the OS and project specific work too
 */
const findJestBinPath = () => {
    const { root } = coc_nvim_1.workspace;
    if (isBootstrappedWithCreateReactApp(root)) {
        return `npm test --`;
    }
    const jestBinPath = getLocalPathForExecutable(root, `jest${nodeBinExtension}`);
    if (jestBinPath) {
        return `node ${jestBinPath}`;
    }
    return '';
};
/**
 * Returns the command to run jest. It handles OS and CRA bootstrapped projects
 */
const makeJestBinCmd = () => __awaiter(void 0, void 0, void 0, function* () {
    const jestBinPath = findJestBinPath();
    if (jestBinPath === '') {
        return 'jest';
    }
    return jestBinPath;
});
exports.makeJestBinCmd = makeJestBinCmd;
//# sourceMappingURL=jest.js.map